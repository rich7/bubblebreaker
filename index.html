<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BubbleBreaker</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .bubble {
            box-shadow: inset -3px -3px 8px rgba(0,0,0,0.3),
                        inset 3px 3px 8px rgba(255,255,255,0.5);
            transform-origin: center;
            animation-fill-mode: forwards;
        }
        .bubble:hover {
            transform: scale(1.1);
            box-shadow: inset -4px -4px 10px rgba(0,0,0,0.4),
                        inset 4px 4px 10px rgba(255,255,255,0.6);
        }
        .bubble-fall {
            animation: fallDown 0.3s ease-in-out;
        }
        .bubble-shift {
            animation: shiftLeft 0.3s ease-in-out;
        }
        @keyframes fallDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        @keyframes shiftLeft {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
        .fallback-styles {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f3f4f6;
        }
    </style>
</head>
<body class="fallback-styles">
    <div id="root"></div>

    <script type="text/babel">
        const COLORS = ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500'];
        const GRID_SIZE = 8;

        function BubbleBreaker() {
            const [grid, setGrid] = React.useState([]);
            const [score, setScore] = React.useState(0);
            const [highScore, setHighScore] = React.useState(() => {
                const saved = localStorage.getItem('bubblebreaker-highscore');
                return saved ? parseInt(saved) : 0;
            });
            const [isProcessing, setIsProcessing] = React.useState(false);

            React.useEffect(() => {
                initializeGrid();
            }, []);

            React.useEffect(() => {
                if (score > highScore) {
                    setHighScore(score);
                    localStorage.setItem('bubblebreaker-highscore', score.toString());
                }
            }, [score, highScore]);

            const initializeGrid = () => {
                const newGrid = Array(GRID_SIZE).fill().map(() =>
                    Array(GRID_SIZE).fill().map(() => ({
                        color: COLORS[Math.floor(Math.random() * COLORS.length)],
                        id: Math.random().toString(36).substr(2, 9),
                        isNew: false,
                        isShifted: false
                    }))
                );
                setGrid(newGrid);
                setScore(0);
                setIsProcessing(false);
            };

            const findConnectedBubbles = (row, col, color, visited = new Set()) => {
                const key = `${row},${col}`;
                if (
                    row < 0 || row >= GRID_SIZE ||
                    col < 0 || col >= GRID_SIZE ||
                    visited.has(key) ||
                    !grid[row][col] ||
                    grid[row][col].color !== color
                ) {
                    return [];
                }

                visited.add(key);
                const connected = [[row, col]];

                [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    connected.push(...findConnectedBubbles(newRow, newCol, color, visited));
                });

                return connected;
            };

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            const handleBubbleClick = async (row, col) => {
                if (!grid[row][col] || isProcessing) return;
                
                setIsProcessing(true);
                const color = grid[row][col].color;
                const connected = findConnectedBubbles(row, col, color);
                
                if (connected.length >= 2) {
                    // Remove bubbles
                    const newGrid = JSON.parse(JSON.stringify(grid));
                    connected.forEach(([r, c]) => {
                        newGrid[r][c] = null;
                    });
                    setGrid(newGrid);
                    await sleep(300);

                    // Drop bubbles
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const column = newGrid.map(row => row[col]).filter(cell => cell !== null);
                        while (column.length < GRID_SIZE) {
                            column.unshift({
                                color: COLORS[Math.floor(Math.random() * COLORS.length)],
                                id: Math.random().toString(36).substr(2, 9),
                                isNew: true
                            });
                        }
                        for (let row = 0; row < GRID_SIZE; row++) {
                            newGrid[row][col] = column[row];
                        }
                    }
                    setGrid(newGrid);
                    await sleep(300);

                    // Update score
                    const points = connected.length * (connected.length - 1);
                    setScore(prevScore => prevScore + points);
                }
                
                setIsProcessing(false);
            };

            const getBubbleClasses = (bubble) => {
                if (!bubble) return 'bg-gray-200';
                const classes = ['bubble', bubble.color];
                if (bubble.isNew) classes.push('bubble-fall');
                if (bubble.isShifted) classes.push('bubble-shift');
                return classes.join(' ');
            };

            return (
                <div className="bg-white p-8 rounded-xl shadow-2xl max-w-2xl mx-auto">
                    <h1 className="text-3xl font-bold text-center mb-6">BubbleBreaker</h1>
                    <div className="flex justify-between items-center mb-6">
                        <div className="text-xl">Score: <span className="font-bold">{score}</span></div>
                        <div className="text-xl">Highscore: <span className="font-bold text-blue-600">{highScore}</span></div>
                    </div>
                    <div className="grid grid-cols-8 gap-2 mb-6 mx-auto" style={{maxWidth: '500px'}}>
                        {grid.map((row, rowIndex) =>
                            row.map((bubble, colIndex) => (
                                <button
                                    key={`${rowIndex}-${colIndex}-${bubble?.id || 'empty'}`}
                                    className={`w-full pt-[100%] relative ${getBubbleClasses(bubble)}`}
                                    onClick={() => bubble && handleBubbleClick(rowIndex, colIndex)}
                                    disabled={!bubble || isProcessing}
                                />
                            ))
                        )}
                    </div>
                    <button 
                        onClick={initializeGrid}
                        className="w-full bg-blue-500 text-white py-3 px-6 rounded-lg text-xl font-bold
                            hover:bg-blue-600 transition-colors shadow-lg hover:shadow-xl"
                        disabled={isProcessing}
                    >
                        Nieuw Spel
                    </button>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<BubbleBreaker />);
    </script>
</body>
</html>
