<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BubbleBreaker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    <div id="root"></div>

    <script type="text/babel">
        const COLORS = ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500'];
        const GRID_SIZE = 10;

        function BubbleBreaker() {
            const [grid, setGrid] = React.useState([]);
            const [score, setScore] = React.useState(0);

            React.useEffect(() => {
                initializeGrid();
            }, []);

            const initializeGrid = () => {
                const newGrid = Array(GRID_SIZE).fill().map(() =>
                    Array(GRID_SIZE).fill().map(() => ({
                        color: COLORS[Math.floor(Math.random() * COLORS.length)],
                        id: Math.random().toString(36).substr(2, 9)
                    }))
                );
                setGrid(newGrid);
                setScore(0);
            };

            const findConnectedBubbles = (row, col, color, visited = new Set()) => {
                const key = `${row},${col}`;
                if (
                    row < 0 || row >= GRID_SIZE ||
                    col < 0 || col >= GRID_SIZE ||
                    visited.has(key) ||
                    grid[row][col].color !== color
                ) {
                    return [];
                }

                visited.add(key);
                const connected = [[row, col]];

                [[-1, 0], [1, 0], [0, -1], [0, 1]].forEach(([dr, dc]) => {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    connected.push(...findConnectedBubbles(newRow, newCol, color, visited));
                });

                return connected;
            };

            const handleBubbleClick = (row, col) => {
                const color = grid[row][col].color;
                const connected = findConnectedBubbles(row, col, color);
                
                if (connected.length >= 2) {
                    const newGrid = [...grid];
                    connected.forEach(([r, c]) => {
                        newGrid[r][c] = null;
                    });

                    const points = connected.length * (connected.length - 1);
                    setScore(prevScore => prevScore + points);

                    // Drop bubbles
                    for (let col = 0; col < GRID_SIZE; col++) {
                        const column = newGrid.map(row => row[col]).filter(cell => cell !== null);
                        while (column.length < GRID_SIZE) {
                            column.unshift(null);
                        }
                        for (let row = 0; row < GRID_SIZE; row++) {
                            newGrid[row][col] = column[row];
                        }
                    }

                    // Shift columns left
                    let firstEmptyCol = 0;
                    while (firstEmptyCol < GRID_SIZE) {
                        if (newGrid.every(row => row[firstEmptyCol] === null)) {
                            for (let col = firstEmptyCol; col < GRID_SIZE - 1; col++) {
                                for (let row = 0; row < GRID_SIZE; row++) {
                                    newGrid[row][col] = newGrid[row][col + 1];
                                }
                            }
                            for (let row = 0; row < GRID_SIZE; row++) {
                                newGrid[row][GRID_SIZE - 1] = null;
                            }
                        } else {
                            firstEmptyCol++;
                        }
                    }

                    setGrid(newGrid);
                }
            };

            return (
                <div className="bg-white p-6 rounded-lg shadow-lg">
                    <h1 className="text-2xl font-bold text-center mb-4">BubbleBreaker</h1>
                    <div className="text-lg mb-4">Score: {score}</div>
                    <div className="grid grid-cols-10 gap-1 mb-4">
                        {grid.map((row, rowIndex) =>
                            row.map((bubble, colIndex) => (
                                <button
                                    key={`${rowIndex}-${colIndex}`}
                                    className={`w-8 h-8 rounded-full ${bubble ? bubble.color : 'bg-gray-200'} 
                                        transition-all duration-200 hover:opacity-80`}
                                    onClick={() => bubble && handleBubbleClick(rowIndex, colIndex)}
                                    disabled={!bubble}
                                />
                            ))
                        )}
                    </div>
                    <button 
                        onClick={initializeGrid}
                        className="w-full bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600 transition-colors"
                    >
                        Nieuw Spel
                    </button>
                </div>
            );
        }

        // Render de app
        ReactDOM.render(<BubbleBreaker />, document.getElementById('root'));
    </script>
</body>
</html>
